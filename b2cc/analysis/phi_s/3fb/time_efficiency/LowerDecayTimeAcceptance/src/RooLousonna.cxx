 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooLousonna.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include <math.h> 
 #include "TMath.h" 

//ClassImp(RooLousonna) 

RooLousonna::RooLousonna(const char *name, const char *title, 
                         RooAbsReal& _m,
                         RooAbsReal& _m0,
                         RooAbsReal& _sigma,
                         RooAbsReal& _nu,
                         RooAbsReal& _alpha,
                         RooAbsReal& _n) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  m0("m0","m0",this,_m0),
  sigma("sigma","sigma",this,_sigma),
  nu("nu","nu",this,_nu),
  alpha("alpha","alpha",this,_alpha),
  n("n","n",this,_n)
 { 
 } 


 RooLousonna::RooLousonna(const RooLousonna& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   m0("m0",this,other.m0),
   sigma("sigma",this,other.sigma),
   nu("nu",this,other.nu),
   alpha("alpha",this,other.alpha),
   n("n",this,other.n)
 { 
 } 


 Double_t RooLousonna::evaluate() const 
 { 
   Double_t t = (m-m0)/sigma;
   if (alpha < 0) t = -t;
   
   Double_t absAlpha = fabs((Double_t)alpha);
   if (t >= -absAlpha) {
     return TMath::Student(t,nu);
   } else {
     Double_t b = n*(1+absAlpha*absAlpha/nu)/(absAlpha*(nu+1)/nu)-absAlpha;
     Double_t a = TMath::Power(b+absAlpha,n)*TMath::Student(-absAlpha,nu);
     return a/TMath::Power(b-t, n);
   }
 } 


 Int_t RooLousonna::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
 {
   if( matchArgs(allVars,analVars,m) )
     return 1 ;
   
   return 0;
 }


 Double_t RooLousonna::analyticalIntegral(Int_t code, const char* rangeName) const
 {
   assert(code==1);

   double absAlpha = fabs((Double_t)alpha);

   double tmin = (m.min(rangeName)-m0)/sigma;
   double tmax = (m.max(rangeName)-m0)/sigma;

   bool useLog = false;
   
   if( fabs(n-1.0) < 1.0e-05 )
     useLog = true;
   
   if(alpha < 0) {
     double tmp = tmin;
     tmin = -tmax;
     tmax = -tmp;
   }

   double result = 0.0;
   
   if( tmin >= -absAlpha ) {
     result += sigma*(TMath::StudentI(tmax,nu)-TMath::StudentI(tmin,nu));
   }else if( tmax <= -absAlpha ) {
     Double_t b = n*(1+absAlpha*absAlpha/nu)/(absAlpha*(nu+1)/nu)-absAlpha;
     Double_t a = TMath::Power(b+absAlpha,n)*TMath::Student(-absAlpha,nu);
     
     if(useLog) {
       result += a*sigma*( log(b-tmin) - log(b-tmax) );
     } else {
       result += a*sigma/(1.0-n)*( 1.0/(TMath::Power(b-tmin,n-1.0))
                                   - 1.0/(TMath::Power(b-tmax,n-1.0)) );
     }
   }else{
     Double_t b = n*(1+absAlpha*absAlpha/nu)/(absAlpha*(nu+1)/nu)-absAlpha;
     Double_t a = TMath::Power(b+absAlpha,n)*TMath::Student(-absAlpha,nu);
     
     double term1 = 0.0;
     
     if(useLog) {
       term1 = a*sigma*( log(b-tmin) - log(b+absAlpha) );
     } else {
       term1 = a*sigma/(1.0-n)*( 1.0/(TMath::Power(b-tmin,n-1.0))
                                 - 1.0/(TMath::Power(b+absAlpha,n-1.0)) );
     }
     
     double term2 = sigma*(TMath::StudentI(tmax,nu)-TMath::StudentI(-absAlpha,nu));
     
     result += term1 + term2;
   }
   return result;
 }
