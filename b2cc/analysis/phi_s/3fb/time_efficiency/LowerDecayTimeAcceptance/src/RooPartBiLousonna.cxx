 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooPartBiLousonna.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include <math.h> 
 #include "TMath.h" 

//ClassImp(RooPartBiLousonna) 

RooPartBiLousonna::RooPartBiLousonna(const char *name, const char *title, 
                                     RooAbsReal& _m,
                                     RooAbsReal& _m0,
                                     RooAbsReal& _sigma,
                                     RooAbsReal& _nu,
                                     RooAbsReal& _alpha_l,
                                     RooAbsReal& _n_l,
                                     RooAbsReal& _alpha_r,
                                     RooAbsReal& _n_r) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  m0("m0","m0",this,_m0),
  sigma("sigma","sigma",this,_sigma),
  nu("nu","nu",this,_nu),
  alpha_l("alpha_l","alpha_l",this,_alpha_l),
  n_l("n_l","n_l",this,_n_l),
  alpha_r("alpha_r","alpha_r",this,_alpha_r),
  n_r("n_r","n_r",this,_n_r)
 { 
 } 


 RooPartBiLousonna::RooPartBiLousonna(const RooPartBiLousonna& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   m0("m0",this,other.m0),
   sigma("sigma",this,other.sigma),
   nu("nu",this,other.nu),
   alpha_l("alpha_l",this,other.alpha_l),
   n_l("n_l",this,other.n_l),
   alpha_r("alpha_r",this,other.alpha_r),
   n_r("n_r",this,other.n_r)
 { 
 } 


 Double_t RooPartBiLousonna::evaluate() const 
 { 
   Double_t t = (m-m0)/sigma;
   
   if (t > alpha_r) {
     Double_t b = n_r*(1+alpha_r*alpha_r/nu)/(alpha_r*(nu+1)/nu)-alpha_r;
     Double_t a = TMath::Power(b+alpha_r,n_r)*TMath::Student(alpha_r,nu);
     return a/TMath::Power(b+t, n_r);
   } else if(t < -alpha_l) {
     Double_t b = n_l*(1+alpha_l*alpha_l/nu)/(alpha_l*(nu+1)/nu)-alpha_l;
     Double_t a = TMath::Power(b+alpha_l,n_l)*TMath::Student(-alpha_l,nu);
     return a/TMath::Power(b-t, n_l);
   } else {
     return TMath::Student(t,nu);
   }
 } 
